{"version":3,"file":"listen.js","sourceRoot":"","sources":["../../src/decorators/listen.ts"],"names":[],"mappings":"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","sourcesContent":["import { InitializedEvents, ListenOptions } from '../declarations';\nimport { supportsPassive } from '../utilities';\nimport { BOUND_LISTENERS, ELEMENT_ID } from '../constants';\n\n// Keeps track of the bound events of the components\nconst BOUND_EVENTS = new Map();\n\n/**\n    * @Listen decorator is handling events( custom or normal ) that are being dispatched by elements or components.\n*/\nexport const Listen = ( eventType: string, options?: ListenOptions ) => {\n\n    return ( target: any, methodName: string ) => {\n\n        if( !target.constructor[BOUND_LISTENERS] ) {\n\n            target.constructor[BOUND_LISTENERS] = [];\n\n        }\n\n        if( methodName && typeof target[methodName] === 'function' ) {\n\n            const listenerOptions = supportsPassive && options ? {\n                capture: !!options.capture,\n                passive: !!options.passive,\n            } : options && options.capture ? options.capture : false;\n\n            target.constructor[BOUND_LISTENERS].push({\n                type: eventType,\n                handler: target[methodName],\n                options: listenerOptions,\n                eventTarget: options && options.target ? options.target : false,\n            });\n\n        } else {\n\n            throw Error('The listen decorator needs a valid method name');\n\n        }\n\n    };\n\n};\n\n/**\n    * Adds and removes event listeners based up on the connected and disconnected callback.\n*/\nexport const addRemoveEventListeners = ( targetElement: any, type: string = 'addEventListener' ) => {\n\n    const items: Array<InitializedEvents> = targetElement.constructor[BOUND_LISTENERS];\n    const defaultTarget = targetElement;\n\n    return new Promise(( resolve ) => {\n\n        if( !items ) return resolve();\n\n        items.forEach( ( item ) => {\n\n            const eventTarget = getEventTarget( targetElement, defaultTarget, item.eventTarget );\n            const eventId = `${targetElement[ELEMENT_ID]}${ item.type }${item.eventTarget}${ item.handler.toString()}`;\n\n            if(\n                ( NodeList.prototype.isPrototypeOf(eventTarget) || Array.isArray( eventTarget ) ) &&\n                eventTarget.length > 0\n            ) {\n\n                Array.from(eventTarget).map((target) => initializeEvent( target, eventId, item, targetElement, type ));\n\n            } else {\n\n                initializeEvent( eventTarget, eventId, item, targetElement, type );\n\n            }\n\n        });\n\n        resolve();\n\n    });\n\n}\n\nfunction initializeEvent(target: any, eventId: string, item: InitializedEvents , targetElement: any, type: string ) {\n\n    const hasTarget = typeof target[type] === 'function';\n\n    // Check if even is bound. If so remove it first before applying new one.\n    if( BOUND_EVENTS.has(eventId) && hasTarget ) {\n        target.removeEventListener(item.type, BOUND_EVENTS.get(eventId).callbackWrapper, item.options);\n    }\n\n    // Save event to use as reference.\n    BOUND_EVENTS.set(eventId, {\n        callbackWrapper: (e: Event) => { item.handler.call(targetElement, e); }\n    });\n\n    if( type === 'removeEventListener' ) {\n        BOUND_EVENTS.delete(eventId);\n    } else if( hasTarget ){\n        target[type](item.type, BOUND_EVENTS.get(eventId).callbackWrapper, item.options);\n    }\n\n}\n\nfunction getEventTarget( target: any, defaultTarget: any, eventTarget: any ) {\n\n    if( eventTarget && typeof eventTarget !== 'string' ) {\n\n        return eventTarget;\n\n    }\n\n    if( eventTarget && typeof eventTarget === 'string' ) {\n\n        if( !target[eventTarget] ) throw new Error(`${ eventTarget } has to be called by the @Query or @QueryAll decorator`);\n        return target[eventTarget];\n\n    }\n\n    return defaultTarget;\n\n}"]}