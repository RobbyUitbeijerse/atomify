{"version":3,"file":"listen.js","sourceRoot":"","sources":["../../src/decorators/listen.ts"],"names":[],"mappings":"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","sourcesContent":["import { InitializedEvents, ListenOptions } from '../declarations';\nimport { supportsPassive } from '../utilities';\nimport { BOUND_LISTENERS } from '../constants';\n/**\n    * @Listen decorator is handling events( custom or normal ) that are being dispatched by elements or components.\n*/\nexport const Listen = ( eventType: string, options?: ListenOptions ) => {\n\n    return ( target: any, methodName: string ) => {\n\n        if( !target.constructor[BOUND_LISTENERS] ) {\n\n            target.constructor[BOUND_LISTENERS] = [];\n\n        }\n\n        if( methodName && typeof target[methodName] === 'function' ) {\n\n            const listenerOptions = supportsPassive && options ? {\n                capture: !!options.capture,\n                passive: !!options.passive,\n            } : options && options.capture ? options.capture : false;\n\n            target.constructor[BOUND_LISTENERS].push({\n                type: eventType,\n                handler: target[methodName],\n                options: listenerOptions,\n                eventTarget: options && options.target ? options.target : false,\n            });\n\n        } else {\n\n            throw Error('The listen decorator needs a valid method name');\n\n        }\n\n    };\n\n};\n\n/**\n    * Adds and removes event listeners based up on the connected and disconnected callback.\n*/\nexport const addRemoveEventListeners = ( targetElement: any, type: string = 'addEventListener' ) => {\n\n    const items: Array<InitializedEvents> = targetElement.constructor[BOUND_LISTENERS];\n    const defaultTarget = targetElement;\n\n    return new Promise(( resolve ) => {\n\n        if( !items ) return resolve();\n\n        items.forEach( ( item ) => {\n\n            const eventTarget = getEventTarget( targetElement, defaultTarget, item.eventTarget );\n\n            if(\n                ( NodeList.prototype.isPrototypeOf(eventTarget) || Array.isArray( eventTarget ) ) &&\n                eventTarget.length > 0\n            ) {\n\n                Array.from( eventTarget )\n                    .map( ( target: any ) => target[type]( item.type, (e: CustomEvent) => {\n\n                        item.handler.call( targetElement, e );\n\n                    }, item.options ) );\n\n            } else {\n\n                eventTarget[type](item.type, (e: CustomEvent) => {\n\n                    item.handler.call( targetElement, e );\n\n                }, item.options );\n\n            }\n\n        });\n\n        resolve();\n\n    });\n\n}\n\nfunction getEventTarget( target: any, defaultTarget: any, eventTarget: any ) {\n\n    if( eventTarget && typeof eventTarget !== 'string' ) {\n\n        return eventTarget;\n\n    }\n\n    if( eventTarget && typeof eventTarget === 'string' ) {\n\n        if( !target[eventTarget] ) throw new Error(`${ eventTarget } has to be called by the @Query or @QueryAll decorator`);\n        return target[eventTarget];\n\n    }\n\n    return defaultTarget;\n\n}"]}