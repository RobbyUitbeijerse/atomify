{"version":3,"file":"component.js","sourceRoot":"","sources":["../../src/decorators/component.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAEjE,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,qBAAqB,EAAE,wBAAwB,EAAE,QAAQ,EAAE,MAAM,cAAc,CAAC;AAElI;;;;;;;;;;;;;;;;;;;EAmBE;AACF,MAAM,CAAC,MAAM,SAAS,GAAG,CAAE,OAAyB,EAAG,EAAE;IAErD,mEAAmE;IACnE,gBAAgB,CAAE,OAAO,CAAC,GAAG,CAAE,CAAC;IAEhC,OAAO,CAAsC,WAAc,EAAG,EAAE;QAE5D,MAAM,kBAAkB,GAAM,KAAM,SAAQ,WAAW;YAiBnD;;eAEG;YACH,MAAM,KAAK,kBAAkB;gBAEzB,OAAO,qBAAqB,CAAI,IAAa,CAAE,CAAC;YAEpD,CAAC;YAED,YAAa,GAAG,IAAW;gBAEvB,KAAK,CAAE,IAAI,CAAE,CAAC;gBAEd,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;gBAEvB,IAAI,CAAC,oBAAoB,GAAG,CAAE,OAAO,CAAC,MAAM,CAAE,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC;gBACxE,IAAI,CAAC,kBAAkB,GAAG,CAAE,MAAM,CAAC,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAE,CAAC;gBAC/E,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;gBAE9C,eAAe,CAAE,IAAI,CAAE,CAAC;gBAExB,IAAI,CAAC,UAAU,GAAG,CAAE,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,UAAU,CAAE,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC;YAEhG,CAAC;YAED;;eAEG;YACH,wBAAwB,CAAC,IAAY,EAAE,QAAsB,EAAE,QAAuB;gBAElF,wBAAwB,CAAI,IAAa,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAE,CAAC;YAE1E,CAAC;YAED;;eAEG;YACH,iBAAiB;gBAEb,iBAAiB,CAAE,IAAW,EAAE,OAAO,EAAE,WAAW,CAAC,SAAS,CAAE,CAAC;YAErE,CAAC;YAED;;eAEG;YACH,oBAAoB;gBAEhB,oBAAoB,CAAE,IAAW,EAAE,WAAW,CAAC,SAAS,CAAE,CAAC;YAE/D,CAAC;YAED,gBAAgB;gBAEZ,OAAO,IAAI,OAAO,CAAC,CAAE,OAAO,EAAG,EAAE,CAAC,OAAO,CAAE,IAAI,CAAE,CAAE,CAAC;YAExD,CAAC;YAED;;cAEE;YACF,QAAQ;gBAEJ,QAAQ,CAAE,IAAW,EAAE,OAAO,EAAE,WAAW,CAAC,SAAS,CAAE,CAAC;YAE5D,CAAC;SAGJ,CAAC;QAEF;;;UAGE;QACF,IAAI,CAAC,cAAc,CAAC,GAAG,CAAE,OAAO,CAAC,GAAG,CAAE,EAAG;YAErC,cAAc,CAAC,MAAM,CAAE,OAAO,CAAC,GAAG,EAAE,kBAAkB,CAAE,CAAC;SAE5D;QAED,OAAO,kBAAkB,CAAC;IAE9B,CAAC,CAAA;AAEL,CAAC,CAAA","sourcesContent":["import { attachShadowDom, validateSelector } from '../utilities';\nimport { ComponentOptions, CustomElementConstructor, CustomElementRenderRoot } from '../declarations';\nimport { connectedCallback, disconnectedCallback, getObservedAttributes, attributeChangedCallback, reRender } from '../component';\n\n/**\n* Base Component decorator that creates a custom element on the fly.\n* Developers must provide a tag name for the component.\n*\n* @param tag the name of the custom element to define\n* @param style inline style\n* @param styles multiple inline styles\n* @param shadow opt_in for putting shadow dom on true ( default is false )\n*\n*   Example:\n*   @Component({\n*       tag: 'example-element',\n        style: '.div { display: none; }',\n        styles: ['.div { display: none; }', '.logo { display: block }'],\n        shadow: true\n*   })\n*   export class ExampleElement extends HTMLElement {\n*\n*   }\n*/\nexport const Component = ( options: ComponentOptions ) => {\n\n    // Check if the element tag name is a valid custom element selector\n    validateSelector( options.tag );\n\n    return <T extends CustomElementConstructor>( constructor: T ) => {\n\n        const generatedComponent: T = class extends constructor {\n\n            __canAttachShadowDom: boolean;\n            __hasShadyPolyfill: boolean;\n            __nodeName: string;\n\n            /**\n                * Tells the components when it is connected to DOM\n            **/\n            public connected: boolean;\n\n            /**\n                * Node or ShadowRoot into which element DOM should be rendered.\n                * Which is being set in the constructor.\n            **/\n            public renderRoot: CustomElementRenderRoot;\n\n            /**\n                * Returns a list of attributes based on the registrated properties.\n            **/\n            static get observedAttributes() {\n\n                return getObservedAttributes( ( this as any ) );\n\n            }\n\n            constructor( ...args: any[] ) {\n\n                super( args );\n\n                this.connected = false;\n\n                this.__canAttachShadowDom = ( options.shadow ) ? options.shadow : false;\n                this.__hasShadyPolyfill = ( window.ShadyCSS && !window.ShadyCSS.nativeShadow );\n                this.__nodeName = this.nodeName.toLowerCase();\n\n                attachShadowDom( this );\n\n                this.renderRoot = ( this.__canAttachShadowDom && this.shadowRoot ) ? this.shadowRoot : this;\n\n            }\n\n            /**\n                * Is called each time a attribute that is defined in the observedAttributes is changed.\n            **/\n            attributeChangedCallback(name: string, oldValue: string| null, newValue: string | null) {\n\n                attributeChangedCallback( ( this as any ), name, oldValue, newValue );\n\n            }\n\n            /**\n                * ConnectedCallback is fired each time the custom element is appended into a document-connected element.\n            **/\n            connectedCallback() {\n\n                connectedCallback( this as any, options, constructor.prototype );\n\n            }\n\n            /**\n                * DisconnectedCallback is fired each time the custom element is disconnected from the document's DOM.\n            **/\n            disconnectedCallback() {\n\n                disconnectedCallback( this as any, constructor.prototype );\n\n            }\n\n            componentOnReady() {\n\n                return new Promise(( resolve ) => resolve( this ) );\n\n            }\n\n            /**\n                * Rerender function thats being called when a property changes\n            */\n            reRender() {\n\n                reRender( this as any, options, constructor.prototype );\n\n            }\n\n\n        };\n\n        /**\n        *   Check if custom element is already defined\n        *   Create new custom element when element name is not defined;\n        */\n        if( !customElements.get( options.tag ) ) {\n\n            customElements.define( options.tag, generatedComponent );\n\n        }\n\n        return generatedComponent;\n\n    }\n\n}"]}