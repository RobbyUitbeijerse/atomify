{"version":3,"file":"property.js","sourceRoot":"","sources":["../../src/decorators/property.ts"],"names":[],"mappings":"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","sourcesContent":["import { KeyValue, PropertyOptions, PropertyTarget } from '../declarations';\nimport { propertyConverter, dashToCamelCase } from '../utilities';\nimport { CLASS_PROPERTIES, PROPERTIES, REFLECTED_PROPERTIES_TO_ATTRIBUTE, IS_REFLECTING_PROPERTY, WATCHED_PROPERTIES, IS_REFLECTING_ATTRIBUTE } from '../constants';\n\nconst defaultPropertyDeclaration: PropertyOptions = {\n    reflectToAttribute: false,\n    type: false,\n    reRender: false,\n};\n\n/**\n    * @Prop decorator is declaring props on the component that can be custom properties/attributes.\n    * the props can be reflected to the attributes by setting the reflectToAttribute on true.\n*/\nexport const Prop = ( options?: PropertyOptions ) => {\n\n    return ( target: any, name: string ) => {\n\n        const key = `_${name}`;\n\n        // Ensure that the __classProperties map is there.\n        if( !target.constructor[CLASS_PROPERTIES] ) {\n\n            target.constructor[CLASS_PROPERTIES] = new Map();\n\n        }\n\n        if( !target.constructor[PROPERTIES] ) {\n\n            target.constructor[PROPERTIES] = new Map();\n\n        }\n\n        target.constructor[PROPERTIES].set(name);\n\n        // Check if the property has any options and store them.\n        if( options ) {\n\n            target.constructor[CLASS_PROPERTIES].set( name, options );\n\n        }\n\n        const descriptor = {\n\n            get() {\n\n                return ( this as KeyValue )[key as string];\n\n            },\n\n            set( this: PropertyTarget, value: unknown ) {\n\n                const oldValue = (this as KeyValue)[name as string];\n                (this as KeyValue)[key as string] = value;\n\n                requestUpdate( this, name, oldValue );\n\n            },\n\n            enumerable: true,\n            configurable: true,\n\n        };\n\n        return Object.defineProperty( target, name, descriptor );\n\n    }\n\n}\n\n/**\n    * Initializes propertys to attributes in the connectedcallback when the property has the reflectToAttribute option.\n*/\nexport const initializePropertyToAttributes = ( target: any ) => {\n\n    const reflectedProperties = target[REFLECTED_PROPERTIES_TO_ATTRIBUTE];\n\n    if( !reflectedProperties ) return;\n\n    reflectedProperties.forEach( ( propValue: any, propName: any ) => {\n\n        propertyToAttribute( target, propName, propValue );\n\n    });\n\n    target[REFLECTED_PROPERTIES_TO_ATTRIBUTE] = undefined;\n\n}\n\n/**\n    * Requests an update for the component.\n    * Reflects the property to attribute when needed.\n*/\nconst requestUpdate = ( target: any, name: string, oldValue: any ) => {\n\n    const newValue = target[name];\n    const hasChanged = valueHasChanged( newValue, oldValue );\n    const options: PropertyOptions = target.constructor[CLASS_PROPERTIES].has( name ) ? target.constructor[CLASS_PROPERTIES].get( name ) : defaultPropertyDeclaration;\n\n    // Component can only apply watchers and reflect attributes when it is connected.\n    if( target.connected ) {\n\n        if( hasChanged && target.constructor[WATCHED_PROPERTIES] ) callWatcher( target, name, newValue, oldValue );\n        if( options.reflectToAttribute ) propertyToAttribute( target, name, newValue );\n        if( options.reRender ) target.reRender();\n\n    } else {\n\n        // Ensure that the reflected properties to attribute map is there.\n        if( !target[REFLECTED_PROPERTIES_TO_ATTRIBUTE] ) {\n\n            target[REFLECTED_PROPERTIES_TO_ATTRIBUTE] = new Map();\n\n        }\n\n        // Push the reflected property to attribute in the store to reuse when the component is connected.\n        if( options.reflectToAttribute ) {\n\n            target[REFLECTED_PROPERTIES_TO_ATTRIBUTE].set( name, newValue );\n\n        }\n\n    }\n\n};\n\n/**\n    * Transforms property to attribute.\n*/\nconst propertyToAttribute = ( target: any, propertyName: string, newValue: any ) => {\n\n    const { type } = getType( target, propertyName );\n    const { name, value } = propertyConverter.toAttribute( propertyName, newValue, type );\n\n    if( value === undefined || target.constructor[IS_REFLECTING_PROPERTY] ) return;\n\n    target.constructor[IS_REFLECTING_ATTRIBUTE] = true;\n\n    if( value == null ) {\n\n        target.removeAttribute( name );\n\n    } else {\n\n        target.setAttribute( name, value );\n\n    }\n\n    target.constructor[IS_REFLECTING_ATTRIBUTE] = false;\n\n};\n\n\n/**\n    * Transforms attribute to property.\n*/\nexport const attributeToProperty = ( target: any, attributeName: string, newValue: any ) => {\n\n    if ( target.constructor[IS_REFLECTING_ATTRIBUTE] ) return;\n\n    const { type } = getType( target, attributeName );\n    const { name, value } = propertyConverter.toProperty( attributeName, newValue, type );\n\n    target.constructor[IS_REFLECTING_PROPERTY] = true;\n\n    target[name] = value;\n\n    target.constructor[IS_REFLECTING_PROPERTY] = false;\n\n};\n\n\n/**\n    * Get the type for the property/attribute converter.\n*/\nconst getType = ( target: any, attributeName: string ) => {\n\n    const attrName = dashToCamelCase( attributeName );\n\n    return target.constructor[CLASS_PROPERTIES].has( attrName )\n        ? target.constructor[CLASS_PROPERTIES].get( attrName )\n        : defaultPropertyDeclaration;\n\n};\n\n/**\n    * Checks if there is a watcher set for the property.\n    * Fires the watcher and sends the old and new value to the watcher.\n*/\nconst callWatcher = ( target: any, name: string, newValue: any, oldValue: any )  => {\n\n    const hasWatcher = target.constructor[WATCHED_PROPERTIES].has( name );\n    const watcherName = hasWatcher ? target.constructor[WATCHED_PROPERTIES].get( name ) : false;\n    const watcher = hasWatcher ? target[watcherName].bind( target ) : false;\n\n    if( watcher && typeof watcher === 'function' ) {\n\n        watcher( newValue, oldValue );\n\n    }\n\n}\n\n/**\n    * Function that returns true if `value` is different from `oldValue`.\n*/\nconst valueHasChanged = ( value: unknown, old: unknown ): boolean => {\n\n    // This ensures (old==NaN, value==NaN) always returns false\n    return old !== value && ( old === old || value === value );\n\n};"]}